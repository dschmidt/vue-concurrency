import{computed as e,reactive as n,watch as r,getCurrentInstance as s,effectScope as t,onBeforeUnmount as i,onServerPrefetch as c}from"vue";import o from"caf";function u(e){return new Promise(n=>{const s=r(e,e=>{null!=e&&(n(e),s&&s())},{immediate:!0})})}function a(n,r){return r?function(n,r,s){return e(()=>n().filter(e=>e[r]))}(()=>n()._instances,r):e(()=>[])}function l(n){return e(()=>n().length)}function d(n){return e(()=>{const e=n();return e[e.length-1]})}function f(n){return e(()=>n()[0])}function _(e){return n(e)}function p(){const e={},n=new Promise((n,r)=>{e.resolve=n,e.reject=r});return e.promise=n,e}function h(e){let n="General";e._isDropping&&(n="Drop"),e._isEnqueuing&&(n="Enqueue"),e._isRestartable&&(n="Restartable"),e._isKeepingLatest&&(n="KeepLatest");let r=n+" Task";"General"!==n&&(r=`${r} with maxConcurrency ${e._maxConcurrency}`);const s=e._instances.map(e=>{let n;e.isSuccessful?n="🍏":e.isRunning||e.isEnqueued?n="🍊":(e.isError||e.isCanceled||e.isDropped)&&(n="🔴");const{status:r,value:s,error:t}=e;return{status:`${n} ${r}`,value:s,error:t}});console.log("🚦 "+r),console.table(s)}function g(e){return"test"===process.env.NODE_ENV?Promise.resolve():new Promise(n=>setTimeout(n,e))}function m(e,n){return new e.CancelToken(e=>{n.pr.catch(n=>{"cancel"===n&&e()})})}function E(e){return y(function*(n,...r){return e(n,...r)})}function y(n,r={cancelOnUnmount:!0}){const c=s(),u=_({_scope:t(),_isRestartable:!1,_isDropping:!1,_isEnqueuing:!1,_isKeepingLatest:!1,_maxConcurrency:1,_hasConcurrency:e(()=>u._isRestartable||u._isDropping||u._isEnqueuing||u._isKeepingLatest),isIdle:e(()=>!u.isRunning),isRunning:e(()=>!!u._instances.find(e=>e.isRunning)),isError:e(()=>!(!u.last||!u.last.isError)),_instances:[],_successfulInstances:a(()=>u,"isSuccessful"),_runningInstances:a(()=>u,"isRunning"),_enqueuedInstances:a(()=>u,"isEnqueued"),_notDroppedInstances:a(()=>u,"isNotDropped"),_activeInstances:a(()=>u,"isActive"),performCount:l(()=>u._instances),last:d(()=>u._notDroppedInstances),lastSuccessful:d(()=>u._successfulInstances),firstEnqueued:f(()=>u._enqueuedInstances),cancelAll({force:e}={force:!1}){u._instances.forEach(n=>{try{(e||!n.isDropped&&!n.isFinished)&&n.cancel({force:e})}catch(e){if("cancel"!==e)throw e}})},perform(...r){const s={enqueue:!1,drop:!1};u._hasConcurrency&&(e=>e._runningInstances.length>=e._maxConcurrency)(u)&&(u._isDropping&&(s.drop=!0),u._isRestartable&&(e=>{const n=e._activeInstances[0];n&&n.cancel()})(u),u._isKeepingLatest&&(e=>{e._enqueuedInstances.forEach(e=>{e.isEnqueued=!1,e.isDropped=!0})})(u),(u._isEnqueuing||u._isKeepingLatest)&&(s.enqueue=!0));const t=()=>function(e){if(e._isEnqueuing||e._isKeepingLatest){const{firstEnqueued:n}=e;n&&n._run()}}(u),i=u._scope.run(()=>function(n,r,s){const t=_({id:s.id,isDropped:!1,isEnqueued:!1,hasStarted:!1,isRunning:!1,isFinished:!1,isCanceling:!1,isCanceled:e(()=>t.isCanceling&&t.isFinished),isActive:e(()=>t.isRunning&&!t.isCanceling),isSuccessful:!1,isNotDropped:e(()=>!t.isDropped),isError:e(()=>!!t.error),status:e(()=>{const e=[[t.isRunning,"running"],[t.isEnqueued,"enqueued"],[t.isCanceled,"canceled"],[t.isCanceling,"canceling"],[t.isDropped,"dropped"],[t.isError,"error"],[t.isSuccessful,"success"]].find(([e])=>e);return e&&e[1]}),error:null,value:null,cancel({force:e}={force:!1}){if(e||(t.isCanceling=!0,t.isEnqueued&&(t.isFinished=!0),t.isEnqueued=!1),t.token&&t._canAbort){t.token.abort("cancel");try{t.token.discard()}catch(e){}t.token=void 0,t._canAbort=!1}},canceledOn:e=>(e.pr.catch(e=>{t.cancel()}),t),_run(){!function(e,n,r,s){const t=new o.cancelToken,i=o(n,t);function c(){e.isRunning=!1,e.isFinished=!0}e.token=t,e.hasStarted=!0,e.isRunning=!0,e.isEnqueued=!1,i.call(e,t,...r).then(n=>{e.value=n,e.isSuccessful=!0,c(),e._deferredObject.resolve(n),e._canAbort=!1,s.onFinish(e)}).catch(n=>{"cancel"!==n&&(e.error=n),c(),e._shouldThrow&&e._deferredObject.reject(n),s.onFinish(e)})}(t,n,r,s)},_handled:!0,_deferredObject:p(),_shouldThrow:!1,_canAbort:!0,then:(e,n)=>(t._shouldThrow=!0,t._deferredObject.promise.then(e,n)),catch:(e,n=!0)=>(t._shouldThrow=n,t._deferredObject.promise.catch(e)),finally:e=>(t._shouldThrow=!0,t._deferredObject.promise.finally(e))}),{modifiers:i}=s;return i.drop?t.isDropped=!0:i.enqueue?t.isEnqueued=!0:t._run(),t}(n,r,{modifiers:s,onFinish:t,scope:u._scope,id:u._instances.length+1}));if(!i)throw new Error("Failed to create new task instance due inactive scope. Perhaps you are trying to run a task bound to destroyed component?");return u._instances=[...u._instances,i],i},clear(){this.cancelAll({force:!0}),this._instances=[]},destroy(){this._scope.stop(),this.clear()},restartable:()=>(u._resetModifierFlags(),u._isRestartable=!0,u),drop:()=>(u._resetModifierFlags(),u._isDropping=!0,u),enqueue:()=>(u._resetModifierFlags(),u._isEnqueuing=!0,u),keepLatest:()=>(u._resetModifierFlags(),u._isKeepingLatest=!0,u),_resetModifierFlags(){u._isKeepingLatest=!1,u._isRestartable=!1,u._isEnqueuing=!1,u._isDropping=!1},maxConcurrency:e=>(u._maxConcurrency=e,u)});return c&&r.cancelOnUnmount&&i(()=>{u._instances&&u.destroy()}),u}function q(e,...n){return y(function*(r,...s){let t=yield e.perform(...s).canceledOn(r);for(let e of n)t=yield e.perform(t).canceledOn(r);return t})}function b(...e){return y(function*(n,...r){const s=e.map(e=>e.perform(...r).canceledOn(n));return yield Promise.all(s)})}function v(...e){return y(function*(n,...r){const s=[];for(let t of e)s.push(yield t.perform(...r).canceledOn(n));return s})}const w=()=>"undefined"==typeof window;function C(e){e._deferredObject.promise=e.isError?Promise.reject(e.error):Promise.resolve(e.value),e.cancel=()=>{},e.canceledOn=()=>e,e._run=()=>{},e.then=(...n)=>e._deferredObject.promise.then(...n),e.catch=(...n)=>e._deferredObject.promise.catch(...n),e.finally=(...n)=>e._deferredObject.promise.finally(...n)}function O(e,n){if(w()){const r=n.perform();return c(async()=>{try{await r,R(e,n)}catch(e){}}),r}const[r]=D(e,n).reverse();return r||n.perform()}function R(n,r){const{$root:t}=s(),i=t&&t.context&&t.context.nuxtState;if(!i)throw new Error("Could not access $root.context.nuxtState");i.vueConcurrency||(i.vueConcurrency={}),i.vueConcurrency[n]=e(()=>({instances:r._instances}))}function D(e,n){const r=function(e){if(!j())throw Error("Could not access  window.__NUXT__");return j().vueConcurrency[e].value}(e);return r&&(n._instances=r.instances||[],n._instances.forEach(C),function(e){delete j().vueConcurrency[e]}(e)),n._instances}function j(){return window.__NUXT__}function F(e,n){w()?R(e,n):D(e,n)}function I(r){const s=Object.values(r),t=n({isRunning:e(()=>!!s.find(e=>e.isRunning)),isIdle:e(()=>!t.isRunning),isError:e(()=>!!s.find(e=>e.isError)),...r});return t}export{m as getCancelToken,h as printTask,g as timeout,E as useAsyncTask,b as useParallelTask,q as usePipeTask,F as useSSRPersistance,v as useSequentialTask,y as useTask,I as useTaskGroup,O as useTaskPrefetch,u as waitForValue};
//# sourceMappingURL=vue-concurrency.modern.js.map
